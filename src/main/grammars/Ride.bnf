{
  parserClass="com.wavesplatform.rideplugin.parser.RideParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Ride"
  psiImplClassSuffix="Impl"
  psiPackage="com.wavesplatform.rideplugin.psi"
  psiImplPackage="com.wavesplatform.rideplugin.psi.impl"

  elementTypeHolderClass="com.wavesplatform.rideplugin.psi.RideTypes"
  elementTypeClass="com.wavesplatform.rideplugin.psi.RideElementType"
  tokenTypeClass="com.wavesplatform.rideplugin.psi.RideTokenType"

  tokens=[
    IDENTIFIER = 'regexp:\p{Alpha}\w*'
    //IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    NUMBER ='regexp:[1-9][0-9]*'
    INTEGER = "regexp:[0-9]+"
    BOOL="regexp:true|false"
//    STRING = 'regexp:(\")[^\"]*\"'
    //(?:'|").*(?:'|")
    STRING="regexp:([\"'])((?:\\\1|(?:(?!\1)).)*)(\1)"
    BASE='regexp:base16|base58|base64'
    LBRACE               =  '{'
    RBRACE               =  '}'
    LBRACK               =  '['
    RBRACK               =  ']'
    LPAREN               =  '('
    RPAREN               =  ')'
    COLON                =  ':'
    SEMICOLON            =  ';'
    COMMA                =  ','
    EQ                   =  '=='
    ASSIGN               =  '='
    NOT_EQ               =  '!='
    NOT                  =  '!'
    PLUS_PLUS            =  '++'
    PLUS_ASSIGN          =  '+='
    PLUS                 =  '+'
    MINUS_MINUS          =  '--'
    MINUS_ASSIGN         =  '-='
    MINUS                =  '-'
    COND_OR              =  '||'
    BIT_OR_ASSIGN        =  '|='
    BIT_CLEAR_ASSIGN     =  '&^='
    BIT_CLEAR            =  '&^'
    COND_AND             =  '&&'
    BIT_AND_ASSIGN       =  '&='
    BIT_AND              =  '&'
    BIT_OR               =  '|'
    SHIFT_LEFT_ASSIGN    =  '<<='
    SHIFT_LEFT           =  '<<'
    SEND_CHANNEL         =  '<-'
    LESS_OR_EQUAL        =  '<='
    LESS                 =  '<'
    BIT_XOR_ASSIGN       =  '^='
    BIT_XOR              =  '^'
    MUL_ASSIGN           =  '*='
    MUL                  =  '*'
    QUOTIENT_ASSIGN      =  '/='
    QUOTIENT             =  '/'
    REMAINDER_ASSIGN     =  '%='
    REMAINDER            =  '%'
    SHIFT_RIGHT_ASSIGN   =  '>>='
    SHIFT_RIGHT          =  '>>'
    GREATER_OR_EQUAL     =  '>='
    GREATER              =  '>'
    VAR_ASSIGN           =  ':='
    TRIPLE_DOT           =  '...'
    DOT                  =  '.'
    SEMICOLON_SYNTHETIC  = '<NL>'
    TYPE_                = 'type'
    raw_string           = 'raw_string'
    WHITE_SPACE = 'regexp:\s+'
    COMMENT = 'regexp:#.*'
//    FUNCTION = 'func'
//    LET = 'let'
  ]
}

File ::= Definition*
Definition ::= DirectiveDefinition* (VarDefinition | FunctionDefinition | COMMENT)

DirectiveDefinition ::= '{-#' IDENTIFIER (IDENTIFIER|NUMBER) '#-}'

Statement ::= Expression | ObjectFieldCall | AllTypesLiteral | VarDefinition | FunctionInvocation | ArrayDefinition
| IfStatementDefinition | IDENTIFIER | COMMENT
Expression ::= IntLiteral PLUS IntLiteral

VarDefinition ::= VarEvalDefinition IDENTIFIER ASSIGN (FieldDefinition | FunctionInvocation | StructCreation | MethodInvocation | AllTypesLiteral | FunctionBody)
VarEvalDefinition ::= strict | let

FieldDefinition ::= FunctionInvocation DOT IDENTIFIER

StructCreation ::= IDENTIFIER Arguments

Arguments ::= LPAREN Argument? (COMMA Argument)* RPAREN

Argument ::= BooleanLiteral | StringLiteral | NumberLiteral | IntLiteral |
UnitLiteral | BaseLiteral | ArrayElementAtIndex | ObjectFieldCall | StructCreation | ArrayDefinition | IDENTIFIER

FunctionInvocation ::= IDENTIFIER Arguments (DOT FunctionInvocation)*

MethodInvocation ::= IDENTIFIER DOT FunctionInvocation

ObjectFieldCall ::= IDENTIFIER DOT IDENTIFIER

ArrayElementAtIndex ::= ObjectFieldCall LBRACK INTEGER RBRACK


// FUNCTION
FunctionDefinition ::= func FunctionSignature ASSIGN (FunctionInvocation | FunctionBody)
FunctionSignature ::= IDENTIFIER FunctionArgumentsDefinition
FunctionArgumentsDefinition ::= LPAREN FunctionArgumentDefinition? (COMMA FunctionArgumentDefinition)* RPAREN
FunctionArgumentDefinition ::= IDENTIFIER COLON DataTypesDefinition
FunctionBody ::= LBRACE? Statement* RBRACE?
DataTypesDefinition ::= 'Any' | 'BigInt' | 'Boolean' | 'ByteVector' | 'Int' | 'String' | 'Unit' | 'List' | 'Tuple' | 'Union'

// IF
IfStatementDefinition ::= if LPAREN? BooleanStatementDefinition RPAREN? (ThenDefinition | FunctionBody) ElseBlock?
ElseBlock ::= else FunctionBody
ThenDefinition ::= then (FunctionInvocation | Argument)

BooleanStatementDefinition ::= NotEqualStatementDefinition | EqualStatementDefinition | LessOrEqualStatementDefinition
| LessStatementDefinition | NotStatementDefinition | GreaterOrEqualStatementDefinition | GreaterStatementDefinition

NotEqualStatementDefinition ::= Statement NOT_EQ Statement
EqualStatementDefinition ::= Statement EQ Statement
LessOrEqualStatementDefinition ::= Statement LESS_OR_EQUAL Statement
LessStatementDefinition ::= Statement LESS Statement
NotStatementDefinition ::= NOT Statement
GreaterOrEqualStatementDefinition ::= Statement GREATER_OR_EQUAL Statement
GreaterStatementDefinition ::= Statement GREATER Statement


// TYPES
AllTypesLiteral ::= BooleanLiteral | UnitLiteral | StringLiteral | IntLiteral | NumberLiteral | BaseLiteral | ArrayDefinition

BooleanLiteral ::= true | false
UnitLiteral ::= unit
StringLiteral ::= STRING
IntLiteral ::= INTEGER
NumberLiteral ::= NUMBER
BaseLiteral ::= (base16|base58|base64) StringLiteral
ArrayDefinition ::= LBRACK Argument? (COMMA Argument)* RBRACK