{
  parserClass="com.wavesplatform.rideplugin.parser.RideParser"
  parserUtilClass="com.wavesplatform.rideplugin.parser.RideParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Ride"
  psiImplClassSuffix="Impl"
  psiPackage="com.wavesplatform.rideplugin.psi"
  psiImplPackage="com.wavesplatform.rideplugin.psi.impl"

  psiImplUtilClass="com.wavesplatform.rideplugin.psi.impl.RidePsiImplUtil"

  implements="com.wavesplatform.rideplugin.psi.RideCompositeElement"
  extends="com.wavesplatform.rideplugin.psi.impl.RideCompositeElementImpl"

  elementTypeHolderClass="com.wavesplatform.rideplugin.psi.RideTypes"
  elementTypeClass="com.wavesplatform.rideplugin.psi.RideElementType"
  tokenTypeClass="com.wavesplatform.rideplugin.psi.RideTokenType"

  elementTypeFactory("var_definition")="com.wavesplatform.rideplugin.psi.impl.RideElementTypeFactory.factory"


  tokens=[
    ASSIGN = "="
    LDBRACKET = "{-#"
    RDBRACKET = "#-}"
    //IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'

    AT_SYMBOL = "@"
    TRUE = "true"
    FALSE = "false"
    IF = "if"
    ELSE = "else"
    UNIT = "unit"
    //(?:'|").*(?:'|")
    //STRING="regexp:([\"'])((?:\\\1|(?:(?!\1)).)*)(\1)"
    //BASE='regexp:base16|base58|base64'
    PERCENT = '%'
    UNDERSCORE = "_"
    LBRACKET = '['
    RBRACKET = ']'
    LBRACE               =  '{'
    RBRACE               =  '}'
    LPAREN               =  '('
    RPAREN               =  ')'
    COLON                =  ':'
    COMMA                =  ','
    EQ                   =  '=='
    NOT_EQ               =  '!='
    BANG                  =  '!'
    PLUS                 =  '+'
    MINUS_MINUS          =  '--'
    MINUS_ASSIGN         =  '-='
    MINUS                =  '-'
    COND_OR              =  '||'
    BIT_OR_ASSIGN        =  '|='
    BIT_CLEAR_ASSIGN     =  '&^='
    BIT_CLEAR            =  '&^'
    COND_AND             =  '&&'
    BIT_AND_ASSIGN       =  '&='
    BIT_AND              =  '&'
    BIT_OR               =  '|'
    MUL                  =  '*'
    SLASH             =  '/'
    GREATER_OR_EQUAL     =  '>='
    LESS_OR_EQUAL     =  '<='
    GT              =  '>'
    LESS                 =  '<'
    DOT                  =  '.'
    CONCAT = '++'
    APPEND = ':+'
    PREPEND = '::'
    FUNCTION = 'func'
    MATCH = 'match'
    CASE = 'case'
    STRICT = 'strict'
    LET = 'let'
    IF = 'if'
    THEN = 'then'
    FOLD_KW = "FOLD"
    NIL = 'nil'
    BOOL="regexp:true|false"
    COMMENT = 'regexp:#.*'
    INTEGER ="regexp:[0-9_]+"
    WHITE_SPACE = 'regexp:\s+'
    NEW_LINE = "regexp:(\r|\n|\r\n)"
    STRING = 'regexp:(\")[^\"]*\"'
    SQSTRING = "regexp:(')[^']*'"
    UPPER_ID = 'regexp:[A-Z][a-zA-Z0-9]*'
    LOWER_ID = 'regexp:[a-z][a-zA-Z0-9]*'
    IDENT = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    //INT = "regexp:[0-9]+"
  ]
  extends(".*expr") = expr
}

//[A-Z][a-zA-Z0-9]* CamelCase Upper
//[a-z][a-zA-Z0-9]* CamelCase Lower

program ::= all
all ::= directive* element*
private element ::= !<<eof>> statement {pin=2 recoverWhile=property_recover}
private property_recover ::= !(UNIT | NIL | AT_SYMBOL | FUNCTION | LET | STRICT | TRUE | FALSE |IF |ELSE | LDBRACKET
| RDBRACKET | PERCENT | LESS_OR_EQUAL | GREATER_OR_EQUAL
| INT | STRING | IDENT | PLUS | MINUS| BANG | ASTERISK |SLASH | LESS |GT|EQ | LBRACKET | RBRACKET
| NOT_EQ | COMMA | ASSIGN |  COLON | LPAREN |RPAREN |LBRACE |RBRACE | MATCH | CASE | FOLD_KW | LOWER_ID | UPPER_ID)

directive ::= LDBRACKET IDENT (UPPER_ID|INTEGER) RDBRACKET

statement ::= var_declaration_statement | expr

var_declaration_statement ::= (LET|STRICT) (tuple_definition | var_definition) ASSIGN (expr | closure) {pin=1}
//closure ::= (LBRACE|LPAREN)? block_state (RBRACE|RPAREN)?
closure ::= LBRACE block_state RBRACE
          | LPAREN block_state RPAREN
          | block_state

case_closure ::= LBRACE block_state RBRACE
          | LPAREN block_state RPAREN
          | block_state

tuple_definition ::= LPAREN var_definition (COMMA var_definition)* RPAREN {pin(".*")=1}

var_definition ::= LOWER_ID | UPPER_ID{
    implements="com.wavesplatform.rideplugin.psi.RideNamedElement"
    extends="com.wavesplatform.rideplugin.psi.impl.RideVarDefinitionBaseImpl"
    stubClass="com.wavesplatform.rideplugin.stubs.RideVarDefinitionStub"
}

expr ::= equal_group
        | index_group
        | conditional_group
        | list_op_group
        | calc_prefix_group
        | definition_group
        | sum_group
        | product_group
        | call_group
        | primary_group
        | prefix_group
        {
        extraRoot=true
        //todo methods=[resolveType]
        }

private equal_group ::= equal_expr | not_equal_expr
equal_expr ::= expr EQ expr
not_equal_expr ::= expr NOT_EQ expr

private conditional_group ::= less_or_eq_expr | more_or_eq_expr | less_expr | more_expr | and_expr | or_expr
less_expr ::= expr LESS expr
more_expr ::= expr GT expr
less_or_eq_expr ::= expr LESS_OR_EQUAL expr
more_or_eq_expr ::= expr GREATER_OR_EQUAL expr
and_expr ::= expr COND_AND expr
or_expr ::= expr COND_OR expr

private list_op_group ::= concat_expr | append_expr | prepend_expr
concat_expr ::= expr CONCAT expr
append_expr ::= expr APPEND expr
prepend_expr ::= expr PREPEND expr

private sum_group ::= plus_expr | minus_expr
plus_expr ::= expr PLUS expr
minus_expr ::= expr MINUS expr

private product_group ::= mul_expr | div_expr | mod_expr
mul_expr ::= expr MUL expr
div_expr ::= expr SLASH expr
mod_expr ::= expr PERCENT expr

private calc_prefix_group ::= unary_min_expr | unary_not_expr
unary_min_expr ::= MINUS expr  {pin = 1}
unary_not_expr ::= BANG expr  {pin = 1}

private call_group ::= call_expr
call_expr ::=  struct_call | function_call | field_call
struct_call ::= type LPAREN arguments? RPAREN call_chain*
function_call ::= object_function_call | standalone_function_call
standalone_function_call ::= function_name LPAREN arguments? RPAREN call_chain* {pin=2}
object_function_call ::= var_definition DOT function_name LPAREN arguments? RPAREN call_chain* {pin=4}
call_chain ::= call_function_chain | call_field_chain
call_function_chain ::= DOT function_name LPAREN arguments? RPAREN
call_field_chain ::= DOT field_definition
field_call ::= (standalone_function_call | var_definition) (call_function_chain | call_field_chain)+
call_arguments ::= LPAREN arguments? RPAREN  {pin = 1}
arguments ::= argument (COMMA argument)*  {pin(".*")=1}
argument ::= expr

field_definition ::= LOWER_ID

private definition_group ::= func_expr | array_expr | pattern_matching_expr | fold_expr | tuple_expr

//todo doesnt work
private index_group ::= index_expr
index_expr ::= (standalone_function_call | object_function_call | field_call | LOWER_ID) LBRACKET expr RBRACKET (DOT expr)?

private prefix_group ::= if_expr
if_expr ::= IF if_cond (THEN? closure) else_if_block* else_block?
| IF LPAREN if_cond RPAREN (THEN? closure) else_if_block* else_block? {pin=1}
if_cond ::= expr
else_if_block ::= ELSE IF LPAREN? if_cond RPAREN? (THEN? closure) {pin=2}
else_block ::= ELSE closure {pin = 1}

private primary_group ::=  simple_ref_expr | paren_expr | literal_expr
paren_expr ::= LPAREN expr RPAREN {pin=1}

simple_ref_expr ::= LOWER_ID | UPPER_ID
//todo {methods=[getReference resolve setName] }

func_expr ::= annotation_expr? FUNCTION function_name LPAREN param_group? RPAREN ASSIGN closure  {pin=2}
function_name ::= LOWER_ID
block_state ::= element*
param_group ::= param_definition (COMMA param_definition)*  {pin(".*")=1}
param_definition ::= var_definition COLON type {pin(".*")=1}

annotation_expr ::= annotation LPAREN LOWER_ID RPAREN {pin=1}
annotation ::= AT_SYMBOL UPPER_ID {pin=1}

type ::=  tuple_type | array_type | union_type | simple_type
tuple_type ::= LPAREN type (COMMA type)* RPAREN {pin(".*")=1}
array_type ::= UPPER_ID LBRACKET (type | IDENT) RBRACKET {pin=2}
union_type ::= UPPER_ID BIT_OR (UPPER_ID|NIL|UNIT) (BIT_OR (UPPER_ID|NIL|UNIT))* {pin=2}
simple_type ::= UPPER_ID

array_expr ::= LBRACKET arguments? RBRACKET {pin = 1}

pattern_matching_expr ::= MATCH expr LBRACE case_expr*  RBRACE {pin=1}
case_expr ::= CASE (UNDERSCORE | var_definition) COLON? type? '=>' case_closure {pin=1}
//case ::= default_case | certain_type_case_definition
//certain_type_case_definition ::= CASE param_definition '=>' statement* {pin=2}
//default_case ::= CASE UNDERSCORE param_definition? '=>' expr* {pin=2}

fold_expr ::= FOLD_KW LESS INTEGER GT call_arguments {pin=1}

tuple_expr ::= call_arguments

literal_expr ::= boolLiteral
          | numericLiteral
          | stringLiteral
          | byteVectorLiteral
          | nilLiteral
          | unitLiteral
stringLiteral ::= STRING
numericLiteral ::= integerLiteral
boolLiteral ::= TRUE | FALSE
integerLiteral ::= INTEGER
byteVectorLiteral ::= (base16|base58|base64) SQSTRING
nilLiteral ::= NIL
unitLiteral ::= UNIT




